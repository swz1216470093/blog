{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://swz1216470093.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"","slug":"线程原理探究(一)","date":"2021-05-18T09:13:16.567Z","updated":"2021-05-18T09:13:16.567Z","comments":true,"path":"2021/05/18/线程原理探究(一)/","link":"","permalink":"https://swz1216470093.github.io/blog/1970/01/01/%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6(%E4%B8%80)/","excerpt":"","text":"线程原理探究(一)问题：线程创建的方式有几种,优先选哪种（1）继承Thread类，重写run方法 （2）实现Runnable接口，实现run方法，传递给Thread （3）实现Callable接口，实现call方法，传递给FutureTask，再传递给Thread类 重点说一下第三种，第三种本质上也是实现Runable接口，因为FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Future和Runnalbe接口 如果用不到异步的情形下优先选实现Runnable接口，因为代码架构上来说 组合优于继承 而且java不支持多继承，继承了Thread类就不能继承其他类了。 需要异步就用Callable接口 问题：即实现runnable接口，又继承Thread类 会调用哪个方法1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ &quot;:&quot; + &quot;我来自runnable&quot;); &#125;&#125;,&quot;Thread&amp;Runnable&quot;)&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + &quot;我来自Thread类&quot;); &#125;&#125;.start(); 先说结果 输出是Thread&amp;Runnable:我来自Thread类 查看Thread类run方法的源码就可以知道，实现Runable接口时 Thread类的run方法会调用Runable接口的run方法。而继承Thread类时，Thread类的run方法整个被重写，也就不会调用Runable接口的run方法了。 12345678/* What will be run. */private Runnable target;@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 问题：run方法和start方法的区别，能否两次调用start方法先看Thread对象的start方法 1234567891011121314/** * Causes this thread to begin execution; the Java Virtual Machine * calls the &lt;code&gt;run&lt;/code&gt; method of this thread. * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. */ public synchronized void start() &#123; //A zero status value corresponds to state &quot;NEW&quot;. if (threadStatus != 0) throw new IllegalThreadStateException(); //忽略无关代码 start0(); &#125; 从上述源码和注释可以看出，调用Thread对象的start方法后JVM会调用Thread类的run方法，start方法会开启线程的生命周期，而run方法只是一个普通的方法。 同时start方法会检测线程状态，如果线程不是new状态，则会抛出异常，所以start方法不能调用多次。 问题：Callable接口结果怎么得到，出异常了怎么办看FutureTask类的源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** The result to return or exception to throw from get() */private Object outcome; public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125;&#125;protected void set(V v) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); &#125;&#125;protected void setException(Throwable t) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); &#125;&#125;public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);&#125;private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; 从FutureTask的run方法可以看到在FutureTask的run方法中会调用Callable的run方法，如果没有发生异常就调用set(result)方法将结果赋给outcome成员变量， 如果发生异常就将异常对象赋给outcome。调用get方法时会调用report方法判断结果状态，如果没有异常，返回执行结果，如果发生异常，则report方法抛出异常。这里注意一个点，异常不是在执行call方法的时候抛出来的，而是在调用get方法时才抛出来的","categories":[],"tags":[]}],"categories":[],"tags":[]}